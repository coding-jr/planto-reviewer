{"version":3,"file":"231.index.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://typescript-action/./node_modules/langchain/dist/chains/base.js","webpack://typescript-action/./node_modules/langchain/dist/util/set.js","webpack://typescript-action/./node_modules/langchain/dist/chains/sequential_chain.js"],"sourcesContent":["import { RUN_KEY } from \"../schema/index.js\";\nimport { CallbackManager, } from \"../callbacks/manager.js\";\nimport { BaseLangChain } from \"../base_language/index.js\";\n/**\n * Base interface that all chains must implement.\n */\nexport class BaseChain extends BaseLangChain {\n    constructor(fields, \n    /** @deprecated */\n    verbose, \n    /** @deprecated */\n    callbacks) {\n        if (arguments.length === 1 &&\n            typeof fields === \"object\" &&\n            !(\"saveContext\" in fields)) {\n            // fields is not a BaseMemory\n            const { memory, callbackManager, ...rest } = fields;\n            super({ ...rest, callbacks: callbackManager ?? rest.callbacks });\n            this.memory = memory;\n        }\n        else {\n            // fields is a BaseMemory\n            super({ verbose, callbacks });\n            this.memory = fields;\n        }\n    }\n    /**\n     * Return a json-like object representing this chain.\n     */\n    serialize() {\n        throw new Error(\"Method not implemented.\");\n    }\n    async run(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, callbacks) {\n        const isKeylessInput = this.inputKeys.length <= 1;\n        if (!isKeylessInput) {\n            throw new Error(`Chain ${this._chainType()} expects multiple inputs, cannot use 'run' `);\n        }\n        const values = this.inputKeys.length ? { [this.inputKeys[0]]: input } : {};\n        const returnValues = await this.call(values, callbacks);\n        const keys = Object.keys(returnValues);\n        if (keys.length === 1) {\n            return returnValues[keys[0]];\n        }\n        throw new Error(\"return values have multiple keys, `run` only supported when one key currently\");\n    }\n    /**\n     * Run the core logic of this chain and add to output if desired.\n     *\n     * Wraps _call and handles memory.\n     */\n    async call(values, callbacks) {\n        const fullValues = { ...values };\n        if (!(this.memory == null)) {\n            const newValues = await this.memory.loadMemoryVariables(values);\n            for (const [key, value] of Object.entries(newValues)) {\n                fullValues[key] = value;\n            }\n        }\n        const callbackManager_ = await CallbackManager.configure(callbacks, this.callbacks, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleChainStart({ name: this._chainType() }, fullValues);\n        let outputValues;\n        try {\n            outputValues = await this._call(fullValues, runManager);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        if (!(this.memory == null)) {\n            await this.memory.saveContext(values, outputValues);\n        }\n        await runManager?.handleChainEnd(outputValues);\n        // add the runManager's currentRunId to the outputValues\n        Object.defineProperty(outputValues, RUN_KEY, {\n            value: runManager ? { runId: runManager?.runId } : undefined,\n            configurable: true,\n        });\n        return outputValues;\n    }\n    /**\n     * Call the chain on all inputs in the list\n     */\n    async apply(inputs, callbacks) {\n        return Promise.all(inputs.map(async (i, idx) => this.call(i, callbacks?.[idx])));\n    }\n    /**\n     * Load a chain from a json-like object describing it.\n     */\n    static async deserialize(data, values = {}) {\n        switch (data._type) {\n            case \"llm_chain\": {\n                const { LLMChain } = await import(\"./llm_chain.js\");\n                return LLMChain.deserialize(data);\n            }\n            case \"sequential_chain\": {\n                const { SequentialChain } = await import(\"./sequential_chain.js\");\n                return SequentialChain.deserialize(data);\n            }\n            case \"simple_sequential_chain\": {\n                const { SimpleSequentialChain } = await import(\"./sequential_chain.js\");\n                return SimpleSequentialChain.deserialize(data);\n            }\n            case \"stuff_documents_chain\": {\n                const { StuffDocumentsChain } = await import(\"./combine_docs_chain.js\");\n                return StuffDocumentsChain.deserialize(data);\n            }\n            case \"map_reduce_documents_chain\": {\n                const { MapReduceDocumentsChain } = await import(\"./combine_docs_chain.js\");\n                return MapReduceDocumentsChain.deserialize(data);\n            }\n            case \"refine_documents_chain\": {\n                const { RefineDocumentsChain } = await import(\"./combine_docs_chain.js\");\n                return RefineDocumentsChain.deserialize(data);\n            }\n            case \"vector_db_qa\": {\n                const { VectorDBQAChain } = await import(\"./vector_db_qa.js\");\n                return VectorDBQAChain.deserialize(data, values);\n            }\n            default:\n                throw new Error(`Invalid prompt type in config: ${data._type}`);\n        }\n    }\n}\n","/**\n * Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#implementing_basic_set_operations\n */\n/**\n * returns intersection of two sets\n */\nexport function intersection(setA, setB) {\n    const _intersection = new Set();\n    for (const elem of setB) {\n        if (setA.has(elem)) {\n            _intersection.add(elem);\n        }\n    }\n    return _intersection;\n}\n/**\n * returns union of two sets\n */\nexport function union(setA, setB) {\n    const _union = new Set(setA);\n    for (const elem of setB) {\n        _union.add(elem);\n    }\n    return _union;\n}\n/**\n * returns difference of two sets\n */\nexport function difference(setA, setB) {\n    const _difference = new Set(setA);\n    for (const elem of setB) {\n        _difference.delete(elem);\n    }\n    return _difference;\n}\n","import { BaseChain } from \"./base.js\";\nimport { intersection, union, difference } from \"../util/set.js\";\nfunction formatSet(input) {\n    return Array.from(input)\n        .map((i) => `\"${i}\"`)\n        .join(\", \");\n}\n/**\n * Chain where the outputs of one chain feed directly into next.\n */\nexport class SequentialChain extends BaseChain {\n    get inputKeys() {\n        return this.inputVariables;\n    }\n    get outputKeys() {\n        return this.outputVariables;\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"chains\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"returnAll\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chains = fields.chains;\n        this.inputVariables = fields.inputVariables;\n        this.outputVariables = fields.outputVariables ?? [];\n        if (this.outputVariables.length > 0 && fields.returnAll) {\n            throw new Error(\"Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.\");\n        }\n        this.returnAll = fields.returnAll ?? false;\n        this._validateChains();\n    }\n    /** @ignore */\n    _validateChains() {\n        if (this.chains.length === 0) {\n            throw new Error(\"Sequential chain must have at least one chain.\");\n        }\n        const memoryKeys = this.memory?.memoryKeys ?? [];\n        const inputKeysSet = new Set(this.inputKeys);\n        const memoryKeysSet = new Set(memoryKeys);\n        const keysIntersection = intersection(inputKeysSet, memoryKeysSet);\n        if (keysIntersection.size > 0) {\n            throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);\n        }\n        const availableKeys = union(inputKeysSet, memoryKeysSet);\n        for (const chain of this.chains) {\n            const missingKeys = difference(new Set(chain.inputKeys), availableKeys);\n            if (missingKeys.size > 0) {\n                throw new Error(`Missing variables for chain \"${chain._chainType()}\": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`);\n            }\n            const outputKeysSet = new Set(chain.outputKeys);\n            const overlappinOutputKeys = intersection(availableKeys, outputKeysSet);\n            if (overlappinOutputKeys.size > 0) {\n                throw new Error(`The following output variables for chain \"${chain._chainType()}\" are overlapping: ${formatSet(overlappinOutputKeys)}. This can lead to unexpected behaviour.`);\n            }\n            for (const outputKey of outputKeysSet) {\n                availableKeys.add(outputKey);\n            }\n        }\n        if (this.outputVariables.length === 0) {\n            if (this.returnAll) {\n                const outputKeys = difference(availableKeys, inputKeysSet);\n                this.outputVariables = Array.from(outputKeys);\n            }\n            else {\n                this.outputVariables = this.chains[this.chains.length - 1].outputKeys;\n            }\n        }\n        else {\n            const missingKeys = difference(new Set(this.outputVariables), new Set(availableKeys));\n            if (missingKeys.size > 0) {\n                throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`);\n            }\n        }\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        let input = values;\n        const allChainValues = {};\n        for (const chain of this.chains) {\n            input = await chain.call(input, runManager?.getChild());\n            for (const key of Object.keys(input)) {\n                allChainValues[key] = input[key];\n            }\n        }\n        const output = {};\n        for (const key of this.outputVariables) {\n            output[key] = allChainValues[key];\n        }\n        return output;\n    }\n    _chainType() {\n        return \"sequential_chain\";\n    }\n    static async deserialize(data) {\n        const chains = [];\n        const inputVariables = data.input_variables;\n        const outputVariables = data.output_variables;\n        const serializedChains = data.chains;\n        for (const serializedChain of serializedChains) {\n            const deserializedChain = await BaseChain.deserialize(serializedChain);\n            chains.push(deserializedChain);\n        }\n        return new SequentialChain({ chains, inputVariables, outputVariables });\n    }\n    serialize() {\n        const chains = [];\n        for (const chain of this.chains) {\n            chains.push(chain.serialize());\n        }\n        return {\n            _type: this._chainType(),\n            input_variables: this.inputVariables,\n            output_variables: this.outputVariables,\n            chains,\n        };\n    }\n}\n/**\n * Simple chain where a single string output of one chain is fed directly into the next.\n * @augments BaseChain\n * @augments SimpleSequentialChainInput\n *\n * @example\n * ```ts\n * import { SimpleSequentialChain, LLMChain } from \"langchain/chains\";\n * import { OpenAI } from \"langchain/llms/openai\";\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * // This is an LLMChain to write a synopsis given a title of a play.\n * const llm = new OpenAI({ temperature: 0 });\n * const template = `You are a playwright. Given the title of play, it is your job to write a synopsis for that title.\n *\n * Title: {title}\n * Playwright: This is a synopsis for the above play:`\n * const promptTemplate = new PromptTemplate({ template, inputVariables: [\"title\"] });\n * const synopsisChain = new LLMChain({ llm, prompt: promptTemplate });\n *\n *\n * // This is an LLMChain to write a review of a play given a synopsis.\n * const reviewLLM = new OpenAI({ temperature: 0 })\n * const reviewTemplate = `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n * Play Synopsis:\n * {synopsis}\n * Review from a New York Times play critic of the above play:`\n * const reviewPromptTempalte = new PromptTemplate({ template: reviewTemplate, inputVariables: [\"synopsis\"] });\n * const reviewChain = new LLMChain({ llm: reviewLLM, prompt: reviewPromptTempalte });\n *\n * const overallChain = new SimpleSequentialChain({chains: [synopsisChain, reviewChain], verbose:true})\n * const review = await overallChain.run(\"Tragedy at sunset on the beach\")\n * // the variable review contains resulting play review.\n * ```\n */\nexport class SimpleSequentialChain extends BaseChain {\n    get inputKeys() {\n        return [this.inputKey];\n    }\n    get outputKeys() {\n        return [this.outputKey];\n    }\n    constructor(fields) {\n        super(fields.memory, fields.verbose, fields.callbacks ?? fields.callbackManager);\n        Object.defineProperty(this, \"chains\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"output\"\n        });\n        Object.defineProperty(this, \"trimOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chains = fields.chains;\n        this.trimOutputs = fields.trimOutputs ?? false;\n        this._validateChains();\n    }\n    /** @ignore */\n    _validateChains() {\n        for (const chain of this.chains) {\n            if (chain.inputKeys.length !== 1) {\n                throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`);\n            }\n            if (chain.outputKeys.length !== 1) {\n                throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`);\n            }\n        }\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        let input = values[this.inputKey];\n        for (const chain of this.chains) {\n            input = await chain.run(input, runManager?.getChild());\n            if (this.trimOutputs) {\n                input = input.trim();\n            }\n            await runManager?.handleText(input);\n        }\n        return { [this.outputKey]: input };\n    }\n    _chainType() {\n        return \"simple_sequential_chain\";\n    }\n    static async deserialize(data) {\n        const chains = [];\n        const serializedChains = data.chains;\n        for (const serializedChain of serializedChains) {\n            const deserializedChain = await BaseChain.deserialize(serializedChain);\n            chains.push(deserializedChain);\n        }\n        return new SimpleSequentialChain({ chains });\n    }\n    serialize() {\n        const chains = [];\n        for (const chain of this.chains) {\n            chains.push(chain.serialize());\n        }\n        return {\n            _type: this._chainType(),\n            chains,\n        };\n    }\n}\n"],"names":[],"sourceRoot":""}